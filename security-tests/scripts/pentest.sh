#!/bin/bash
# =============================================================================
# Pentest AvanÃ§ado - Construgame API
# =============================================================================
# Este script simula o que um pentester profissional faria:
# 1. Reconhecimento de endpoints
# 2. Testes de autenticaÃ§Ã£o
# 3. Testes de autorizaÃ§Ã£o (BOLA/IDOR)
# 4. SQL Injection avanÃ§ado
# 5. JWT manipulation
# 6. Business logic flaws
# 7. Rate limiting bypass
# =============================================================================

set -e

# ConfiguraÃ§Ãµes
BASE_URL="${1:-http://localhost:3000}"
REPORT_DIR="security-tests/reports"
DATE=$(date +%Y%m%d_%H%M%S)
REPORT_FILE="$REPORT_DIR/pentest-report-$DATE.md"

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Contadores
VULNS_CRITICAL=0
VULNS_HIGH=0
VULNS_MEDIUM=0
VULNS_LOW=0
VULNS_INFO=0

mkdir -p "$REPORT_DIR"

# FunÃ§Ã£o para logging
log_finding() {
    local severity=$1
    local title=$2
    local description=$3
    local endpoint=$4
    local evidence=$5
    
    case $severity in
        CRITICAL) ((VULNS_CRITICAL++)); color=$RED; icon="ðŸ”´" ;;
        HIGH) ((VULNS_HIGH++)); color=$RED; icon="ðŸŸ " ;;
        MEDIUM) ((VULNS_MEDIUM++)); color=$YELLOW; icon="ðŸŸ¡" ;;
        LOW) ((VULNS_LOW++)); color=$CYAN; icon="ðŸ”µ" ;;
        INFO) ((VULNS_INFO++)); color=$GREEN; icon="â„¹ï¸" ;;
    esac
    
    echo -e "${color}[$severity]${NC} $title"
    
    # Adiciona ao relatÃ³rio
    echo "" >> "$REPORT_FILE"
    echo "### $icon [$severity] $title" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    echo "**Endpoint:** \`$endpoint\`" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    echo "**DescriÃ§Ã£o:** $description" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    if [ -n "$evidence" ]; then
        echo "**EvidÃªncia:**" >> "$REPORT_FILE"
        echo '```' >> "$REPORT_FILE"
        echo "$evidence" >> "$REPORT_FILE"
        echo '```' >> "$REPORT_FILE"
    fi
}

# Inicializa relatÃ³rio
cat > "$REPORT_FILE" << 'EOF'
# ðŸ”’ RelatÃ³rio de Pentest - Construgame API

**Data:** $(date)
**Target:** $BASE_URL
**Tipo:** Automated Security Assessment

---

## SumÃ¡rio Executivo

Este relatÃ³rio contÃ©m os resultados do pentest automatizado realizado na API Construgame.

---

## Findings

EOF

sed -i "s|\$(date)|$(date)|g" "$REPORT_FILE"
sed -i "s|\$BASE_URL|$BASE_URL|g" "$REPORT_FILE"

echo -e "${GREEN}================================================${NC}"
echo -e "${GREEN}  PENTEST AVANÃ‡ADO - Construgame API${NC}"
echo -e "${GREEN}================================================${NC}"
echo -e "Target: ${YELLOW}$BASE_URL${NC}"
echo -e "Report: ${YELLOW}$REPORT_FILE${NC}"
echo ""

# =============================================================================
# 1. RECONHECIMENTO
# =============================================================================
echo -e "\n${BLUE}[1/7] RECONHECIMENTO${NC}"
echo -e "-------------------------------------------"

# Baixar OpenAPI spec
echo -e "  Baixando especificaÃ§Ã£o OpenAPI..."
OPENAPI_SPEC=$(curl -s --max-time 5 --max-time 10 "$BASE_URL/docs/json" 2>/dev/null)
TOTAL_ENDPOINTS=$(echo "$OPENAPI_SPEC" | jq -r '.paths | keys | length' 2>/dev/null || echo "0")
echo -e "  ${GREEN}âœ“${NC} Total de endpoints encontrados: $TOTAL_ENDPOINTS"

# Verificar tecnologias expostas
echo -e "  Verificando information disclosure..."
HEADERS=$(curl -sI --max-time 5 "$BASE_URL/api/v1/health" 2>/dev/null)

if echo "$HEADERS" | grep -qi "x-powered-by"; then
    TECH=$(echo "$HEADERS" | grep -i "x-powered-by" | cut -d: -f2 | xargs)
    log_finding "LOW" "Technology Disclosure" "O header X-Powered-By expÃµe a tecnologia usada" "/api/v1/health" "X-Powered-By: $TECH"
else
    echo -e "  ${GREEN}âœ“${NC} X-Powered-By nÃ£o exposto"
fi

# Verificar se Swagger estÃ¡ exposto em produÃ§Ã£o
SWAGGER_RESPONSE=$(curl -s --max-time 5 -o /dev/null -w "%{http_code}" --max-time 5 "$BASE_URL/docs" 2>/dev/null)
if [ "$SWAGGER_RESPONSE" = "200" ]; then
    log_finding "INFO" "Swagger UI Exposto" "A documentaÃ§Ã£o Swagger estÃ¡ acessÃ­vel. Considerar restringir em produÃ§Ã£o." "/docs" "HTTP 200 OK"
fi

# =============================================================================
# 2. TESTES DE AUTENTICAÃ‡ÃƒO
# =============================================================================
echo -e "\n${BLUE}[2/7] TESTES DE AUTENTICAÃ‡ÃƒO${NC}"
echo -e "-------------------------------------------"

# Teste de rotas sem autenticaÃ§Ã£o
echo -e "  Testando rotas pÃºblicas..."
PUBLIC_ENDPOINTS=(
    "/api/v1/health"
    "/api/v1/info"
)

SHOULD_BE_PROTECTED=(
    "/api/v1/games"
    "/api/v1/organization"
    "/api/v1/users"
    "/api/v1/tasks"
    "/api/v1/kpis"
)

for endpoint in "${SHOULD_BE_PROTECTED[@]}"; do
    response=$(curl -s --max-time 5 -o /dev/null -w "%{http_code}" "$BASE_URL$endpoint" 2>/dev/null)
    if [ "$response" = "200" ]; then
        log_finding "CRITICAL" "Endpoint sem AutenticaÃ§Ã£o" "Endpoint protegido acessÃ­vel sem token JWT" "$endpoint" "HTTP $response - Deveria retornar 401"
    else
        echo -e "  ${GREEN}âœ“${NC} $endpoint protegido (HTTP $response)"
    fi
done

# Teste de brute force no login
echo -e "  Testando rate limiting no login..."
LOGIN_ENDPOINT="/api/v1/auth/web/token"
RATE_LIMIT_HIT=false
for i in {1..20}; do
    response=$(curl -s --max-time 5 -o /dev/null -w "%{http_code}" -X POST \
        -H "Content-Type: application/json" \
        -d '{"email":"test@test.com","password":"wrongpassword"}' \
        "$BASE_URL$LOGIN_ENDPOINT" 2>/dev/null)
    if [ "$response" = "429" ]; then
        echo -e "  ${GREEN}âœ“${NC} Rate limiting ativo no login apÃ³s $i tentativas"
        RATE_LIMIT_HIT=true
        break
    fi
done

if [ "$RATE_LIMIT_HIT" = false ]; then
    log_finding "HIGH" "Rate Limiting Fraco no Login" "Endpoint de login permite muitas tentativas sem bloqueio" "$LOGIN_ENDPOINT" "20+ tentativas sem HTTP 429"
fi

# =============================================================================
# 3. TESTES DE AUTORIZAÃ‡ÃƒO (BOLA/IDOR)
# =============================================================================
echo -e "\n${BLUE}[3/7] TESTES DE AUTORIZAÃ‡ÃƒO (BOLA/IDOR)${NC}"
echo -e "-------------------------------------------"
echo -e "  ${YELLOW}âš ${NC} Testes BOLA requerem tokens de usuÃ¡rios diferentes"
echo -e "  ${YELLOW}âš ${NC} Execute o script de setup para criar usuÃ¡rios de teste"
echo -e "  ${YELLOW}âš ${NC} Veja: security-tests/scripts/setup-pentest-users.sh"

# Teste de UUID enumeration
echo -e "  Testando UUID enumeration..."
SEQUENTIAL_UUIDS=(
    "00000000-0000-0000-0000-000000000001"
    "00000000-0000-0000-0000-000000000002"
    "11111111-1111-1111-1111-111111111111"
)

for uuid in "${SEQUENTIAL_UUIDS[@]}"; do
    response=$(curl -s --max-time 5 -o /dev/null -w "%{http_code}" "$BASE_URL/api/v1/organization/$uuid" 2>/dev/null)
    # Se retornar algo diferente de 401/403/404, pode indicar info leak
    if [ "$response" != "401" ] && [ "$response" != "403" ] && [ "$response" != "404" ]; then
        log_finding "MEDIUM" "PossÃ­vel UUID Enumeration" "UUID previsÃ­vel retorna resposta diferente" "/api/v1/organization/$uuid" "HTTP $response"
    fi
done
echo -e "  ${GREEN}âœ“${NC} UUID enumeration nÃ£o detectado (respostas 401/403/404)"

# =============================================================================
# 4. SQL INJECTION AVANÃ‡ADO
# =============================================================================
echo -e "\n${BLUE}[4/7] SQL INJECTION AVANÃ‡ADO${NC}"
echo -e "-------------------------------------------"

# Payloads avanÃ§ados
SQLI_PAYLOADS=(
    "' OR '1'='1"
    "' OR '1'='1' --"
    "' OR '1'='1' /*"
    "1; DROP TABLE users--"
    "1' AND '1'='1"
    "1' AND SLEEP(5)--"
    "1'; WAITFOR DELAY '0:0:5'--"
    "1' UNION SELECT NULL,NULL,NULL--"
    "1' ORDER BY 1--"
    "admin'--"
    "' UNION SELECT username,password FROM users--"
    "1; SELECT pg_sleep(5)--"
)

echo -e "  Testando ${#SQLI_PAYLOADS[@]} payloads de SQL Injection..."

SQLI_FOUND=false
for payload in "${SQLI_PAYLOADS[@]}"; do
    # Encode payload
    encoded=$(echo -n "$payload" | jq -sRr @uri)
    
    # Testar em query param
    start_time=$(date +%s%N)
    response=$(curl -s --max-time 5 -o /dev/null -w "%{http_code}" "$BASE_URL/api/v1/health?id=$encoded" 2>/dev/null)
    end_time=$(date +%s%N)
    
    # Calcular tempo de resposta (detectar time-based SQLi)
    elapsed=$(( (end_time - start_time) / 1000000 ))
    
    # Se demorar mais de 4 segundos, pode ser time-based SQLi
    if [ "$elapsed" -gt 4000 ]; then
        log_finding "CRITICAL" "PossÃ­vel Time-based SQL Injection" "Resposta demorou ${elapsed}ms com payload de sleep" "/api/v1/health?id=$encoded" "Tempo de resposta: ${elapsed}ms"
        SQLI_FOUND=true
    fi
    
    # Se retornar 500, pode indicar SQLi
    if [ "$response" = "500" ]; then
        log_finding "HIGH" "PossÃ­vel SQL Injection (Error-based)" "Payload causou erro 500 no servidor" "/api/v1/health?id=$encoded" "HTTP 500 com payload: $payload"
        SQLI_FOUND=true
    fi
done

if [ "$SQLI_FOUND" = false ]; then
    echo -e "  ${GREEN}âœ“${NC} Nenhuma vulnerabilidade SQLi detectada"
fi

# =============================================================================
# 5. JWT MANIPULATION
# =============================================================================
echo -e "\n${BLUE}[5/7] JWT MANIPULATION${NC}"
echo -e "-------------------------------------------"

# Testar JWT none algorithm
echo -e "  Testando JWT 'none' algorithm..."
# JWT com algorithm: none
NONE_JWT="eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9."

response=$(curl -s --max-time 5 -o /dev/null -w "%{http_code}" \
    -H "Authorization: Bearer $NONE_JWT" \
    "$BASE_URL/api/v1/organization" 2>/dev/null)

if [ "$response" = "200" ]; then
    log_finding "CRITICAL" "JWT None Algorithm Aceito" "API aceita tokens JWT com algorithm 'none'" "/api/v1/organization" "Token com alg:none retornou HTTP 200"
else
    echo -e "  ${GREEN}âœ“${NC} JWT 'none' algorithm rejeitado (HTTP $response)"
fi

# Testar JWT expirado
echo -e "  Testando JWT expirado..."
# JWT expirado (exp: 2020-01-01)
EXPIRED_JWT="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiZXhwIjoxNTc3ODM2ODAwfQ.invalid"

response=$(curl -s --max-time 5 -o /dev/null -w "%{http_code}" \
    -H "Authorization: Bearer $EXPIRED_JWT" \
    "$BASE_URL/api/v1/organization" 2>/dev/null)

if [ "$response" = "200" ]; then
    log_finding "CRITICAL" "JWT Expirado Aceito" "API aceita tokens JWT expirados" "/api/v1/organization" "Token expirado retornou HTTP 200"
else
    echo -e "  ${GREEN}âœ“${NC} JWT expirado rejeitado (HTTP $response)"
fi

# Testar JWT malformado
echo -e "  Testando JWT malformado..."
MALFORMED_JWTS=(
    "invalid.jwt.token"
    "eyJhbGciOiJIUzI1NiJ9.eyJ0ZXN0IjoiMSJ9"  # Sem assinatura
    "Bearer "
    ""
)

for jwt in "${MALFORMED_JWTS[@]}"; do
    response=$(curl -s --max-time 5 -o /dev/null -w "%{http_code}" \
        -H "Authorization: Bearer $jwt" \
        "$BASE_URL/api/v1/organization" 2>/dev/null)
    
    if [ "$response" = "200" ]; then
        log_finding "CRITICAL" "JWT Malformado Aceito" "API aceita tokens JWT malformados" "/api/v1/organization" "Token malformado retornou HTTP 200"
        break
    fi
done
echo -e "  ${GREEN}âœ“${NC} JWTs malformados rejeitados"

# =============================================================================
# 6. BUSINESS LOGIC FLAWS
# =============================================================================
echo -e "\n${BLUE}[6/7] BUSINESS LOGIC FLAWS${NC}"
echo -e "-------------------------------------------"

# Testar valores negativos
echo -e "  Testando valores negativos em campos numÃ©ricos..."
NEGATIVE_PAYLOADS='{"points": -1000, "score": -999999}'

# Este teste requer autenticaÃ§Ã£o, entÃ£o vamos apenas documentar
echo -e "  ${YELLOW}âš ${NC} Testes de business logic requerem tokens vÃ¡lidos"
echo -e "  ${YELLOW}âš ${NC} Pontos a testar manualmente:"
echo -e "     - Valores negativos em pontos/scores"
echo -e "     - ManipulaÃ§Ã£o de datas (criar no passado/futuro)"
echo -e "     - Race conditions em operaÃ§Ãµes crÃ­ticas"
echo -e "     - Bypass de fluxos obrigatÃ³rios"

# =============================================================================
# 7. RATE LIMITING & DOS
# =============================================================================
echo -e "\n${BLUE}[7/7] RATE LIMITING & DOS${NC}"
echo -e "-------------------------------------------"

echo -e "  Testando rate limiting geral..."
RATE_LIMIT_ENDPOINT="/api/v1/health"
RATE_LIMIT_COUNT=0

for i in {1..100}; do
    response=$(curl -s --max-time 5 -o /dev/null -w "%{http_code}" "$BASE_URL$RATE_LIMIT_ENDPOINT" 2>/dev/null)
    if [ "$response" = "429" ]; then
        RATE_LIMIT_COUNT=$i
        break
    fi
done

if [ "$RATE_LIMIT_COUNT" -gt 0 ]; then
    echo -e "  ${GREEN}âœ“${NC} Rate limiting ativo apÃ³s $RATE_LIMIT_COUNT requests"
else
    log_finding "MEDIUM" "Rate Limiting Ausente/Fraco" "100+ requests sem bloqueio" "$RATE_LIMIT_ENDPOINT" "Nenhum HTTP 429 apÃ³s 100 requests"
fi

# Testar request body grande
echo -e "  Testando proteÃ§Ã£o contra payload grande..."
LARGE_PAYLOAD=$(python3 -c "print('A' * 1000000)" 2>/dev/null || echo "AAAAAAAAAA")
response=$(curl -s --max-time 5 -o /dev/null -w "%{http_code}" -X POST \
    -H "Content-Type: application/json" \
    -d "{\"data\": \"$LARGE_PAYLOAD\"}" \
    "$BASE_URL/api/v1/auth/web/token" 2>/dev/null)

if [ "$response" = "413" ]; then
    echo -e "  ${GREEN}âœ“${NC} ProteÃ§Ã£o contra payload grande ativa (HTTP 413)"
elif [ "$response" = "400" ]; then
    echo -e "  ${GREEN}âœ“${NC} Payload grande rejeitado (HTTP 400)"
else
    log_finding "LOW" "Sem Limite de Payload" "API nÃ£o rejeita payloads muito grandes" "/api/v1/auth/web/token" "HTTP $response com 1MB payload"
fi

# =============================================================================
# RESUMO FINAL
# =============================================================================
echo -e "\n${GREEN}================================================${NC}"
echo -e "${GREEN}  RESUMO DO PENTEST${NC}"
echo -e "${GREEN}================================================${NC}"

# Adiciona resumo ao relatÃ³rio
cat >> "$REPORT_FILE" << EOF

---

## Resumo

| Severidade | Quantidade |
|------------|------------|
| ðŸ”´ Critical | $VULNS_CRITICAL |
| ðŸŸ  High | $VULNS_HIGH |
| ðŸŸ¡ Medium | $VULNS_MEDIUM |
| ðŸ”µ Low | $VULNS_LOW |
| â„¹ï¸ Info | $VULNS_INFO |

**Total de vulnerabilidades:** $((VULNS_CRITICAL + VULNS_HIGH + VULNS_MEDIUM + VULNS_LOW))

---

## RecomendaÃ§Ãµes

1. Revisar e corrigir todas as vulnerabilidades Critical e High imediatamente
2. Planejar correÃ§Ã£o de vulnerabilidades Medium no prÃ³ximo sprint
3. Avaliar vulnerabilidades Low e Info para melhorias de seguranÃ§a
4. Executar pentest manual para testes de BOLA/IDOR com usuÃ¡rios reais
5. Considerar bug bounty program para testes contÃ­nuos

---

## PrÃ³ximos Passos

- [ ] Executar testes BOLA com usuÃ¡rios de organizaÃ§Ãµes diferentes
- [ ] Testar business logic com fluxos reais
- [ ] Revisar autorizaÃ§Ã£o em todos os endpoints
- [ ] Implementar logging de seguranÃ§a
- [ ] Configurar alertas para tentativas de ataque

EOF

echo ""
echo -e "  ${RED}ðŸ”´ Critical:${NC} $VULNS_CRITICAL"
echo -e "  ${RED}ðŸŸ  High:${NC} $VULNS_HIGH"
echo -e "  ${YELLOW}ðŸŸ¡ Medium:${NC} $VULNS_MEDIUM"
echo -e "  ${CYAN}ðŸ”µ Low:${NC} $VULNS_LOW"
echo -e "  ${GREEN}â„¹ï¸  Info:${NC} $VULNS_INFO"
echo ""
echo -e "Total de vulnerabilidades: ${YELLOW}$((VULNS_CRITICAL + VULNS_HIGH + VULNS_MEDIUM + VULNS_LOW))${NC}"
echo ""
echo -e "RelatÃ³rio salvo em: ${GREEN}$REPORT_FILE${NC}"

# Exit code baseado em findings crÃ­ticos
if [ "$VULNS_CRITICAL" -gt 0 ]; then
    echo -e "\n${RED}âš ï¸  VULNERABILIDADES CRÃTICAS ENCONTRADAS!${NC}"
    exit 2
elif [ "$VULNS_HIGH" -gt 0 ]; then
    echo -e "\n${YELLOW}âš ï¸  Vulnerabilidades de alta severidade encontradas.${NC}"
    exit 1
else
    echo -e "\n${GREEN}âœ… Nenhuma vulnerabilidade crÃ­tica ou alta encontrada.${NC}"
    exit 0
fi
